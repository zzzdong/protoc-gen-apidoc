package main

import (
	"strings"

	"google.golang.org/genproto/googleapis/api/annotations"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/types/descriptorpb"
)

type MethodDef struct {
	*protogen.Method
	httpMethod string
	httpPath   string
}

func GenerateFile(gen *protogen.Plugin, file *protogen.File) (*protogen.GeneratedFile, error) {
	filename := file.GeneratedFilenamePrefix + ".apidoc.md"
	g := gen.NewGeneratedFile(filename, file.GoImportPath)

	// g.P("// Code generated by protoc-gen-apidoc.")
	// g.P("// source: ", file.Desc.Path())
	// g.P()

	methods := getAllMethods(file)

	g.P(file.GeneratedFilenamePrefix, " API DOC")
	g.P("======")
	g.P("[toc]")

	for _, method := range methods {
		g.P("## ", string(method.Desc.FullName()))
		g.P()
		g.P(string(method.Comments.Leading))

		// path info
		g.P("`", method.httpMethod, " ", method.httpPath, "`")

		g.P("### Request")
		printMessage(g, method.Input)
		g.P("### Response payload")
		printMessage(g, method.Output)

	}

	return g, nil
}

func getAllMethods(file *protogen.File) []*MethodDef {
	methods := make([]*MethodDef, 0)

	for _, svc := range file.Services {
		for _, method := range svc.Methods {
			if method.Desc.IsStreamingClient() || method.Desc.IsStreamingServer() {
				continue
			}

			methods = append(methods, parseMethod(method))

		}
	}

	return methods
}

func parseMethod(m *protogen.Method) *MethodDef {
	httpMethod := "POST"
	httpPath := string(m.Desc.FullName())

	if opts, ok := m.Desc.Options().(*descriptorpb.MethodOptions); ok {
		if httpRule, ok := proto.GetExtension(opts, annotations.E_Http).(*annotations.HttpRule); ok {
			switch httpRule.GetPattern().(type) {
			case *annotations.HttpRule_Get:
				httpMethod = "GET"
				httpPath = httpRule.GetGet()
			case *annotations.HttpRule_Put:
				httpMethod = "PUT"
				httpPath = httpRule.GetPut()
			case *annotations.HttpRule_Post:
				httpMethod = "POST"
				httpPath = httpRule.GetPost()
			case *annotations.HttpRule_Delete:
				httpMethod = "DELETE"
				httpPath = httpRule.GetDelete()
			case *annotations.HttpRule_Patch:
				httpMethod = "DELETE"
				httpPath = httpRule.GetPatch()
			default:
			}
		}
	}

	method := &MethodDef{Method: m, httpMethod: httpMethod, httpPath: httpPath}

	return method
}

func printMessage(g *protogen.GeneratedFile, message *protogen.Message) {
	// table header
	g.P("| 字段        | 类型           | 描述  |")
	g.P("| ------------- |:-------------:| -----|")

	for _, field := range message.Fields {
		printField(g, field)
	}

}

func printField(g *protogen.GeneratedFile, field *protogen.Field) {
	g.P("|", field.Desc.Name(), "|", field.Desc.Kind().String(), "|", getCompactComment(&field.Comments), "|")
}

func getCompactComment(comment *protogen.CommentSet) string {
	text := strings.Trim(comment.Leading.String(), "/ \t\r\n")
	if len(text) > 0 {
		text += "\t"
	}
	text += strings.Trim(comment.Trailing.String(), "/ \t\r\n")

	text = strings.ReplaceAll(text, "\r", "")
	text = strings.ReplaceAll(text, "\n", "")

	return text
}
